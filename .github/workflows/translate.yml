#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Android strings.xml 英文 → 简体中文翻译工具（固定词典版，准确率高，无需额外安装）
支持 >Move 标记，智能避开占位符
同时支持繁体 → 简体
"""

import sys
import re
from pathlib import Path

# 繁体转简体（需 pip install opencc-python-reimplemented）
try:
    from opencc import OpenCC
    t2s = OpenCC('t2s')
except ImportError:
    print("警告：未安装 opencc，繁体转简体功能不可用（pip install opencc-python-reimplemented）")
    def t2s(text): return text

# 常见 Android 系统字符串翻译词典（来自 AppCompat / Material / 系统官方翻译）
en_to_zh_dict = {
    "Navigate home": "导航到主页",
    "Navigate up": "向上导航",
    "More options": "更多选项",
    "Done": "完成",
    "See all": "查看全部",
    "Choose an app": "选择应用",
    "OFF": "关闭",
    "ON": "开启",
    "Alt+": "Alt + ",
    "Ctrl+": "Ctrl + ",
    "delete": "删除",
    "enter": "回车",
    "Function+": "功能键 + ",
    "Meta+": "Meta + ",
    "Shift+": "Shift + ",
    "space": "空格",
    "Sym+": "符号 + ",
    "Menu+": "菜单 + ",
    "Search…": "搜索…",
    "Clear query": "清除查询",
    "Clear search": "清除搜索",
    "Search": "搜索",
    "Close": "关闭",
    "Cancel": "取消",
    "OK": "确定",
    "Yes": "是",
    "No": "否",
    "Save": "保存",
    "Delete": "删除",
    "Move": "移动",
    "Copy": "复制",
    "Paste": "粘贴",
    "Share": "分享",
    "Settings": "设置",
    # 可以继续添加更多...
}

def has_placeholder(text: str) -> bool:
    """避开含占位符的字符串"""
    return bool(re.search(r'%[0-9]*[sd]|{[^}]+}|@string/|@android:|\\.', text))

def translate_value(value: str) -> str:
    stripped = value.strip()
    
    # 处理 >Move 标记
    prefix = ""
    if stripped.startswith(">"):
        prefix = ">"
        stripped = stripped[1:].strip()
    
    if not stripped or has_placeholder(stripped):
        return value
    
    # 直接匹配词典
    if stripped in en_to_zh_dict:
        return prefix + en_to_zh_dict[stripped]
    
    # 如果是大写短词（如 OFF/ON），尝试匹配
    lower = stripped.lower()
    for en, zh in en_to_zh_dict.items():
        if en.lower() == lower:
            # 保持原大小写风格
            if stripped.isupper():
                return prefix + zh.upper()
            elif stripped.istitle():
                return prefix + zh.capitalize()
            else:
                return prefix + zh
    
    # 没匹配上，至少做繁体转简体
    return prefix + t2s(stripped)

def translate_xml_strings(content: str) -> str:
    """修复版正则：正确捕获 name 和 value"""
    def replace(match):
        name = match.group(1)
        value = match.group(2)  # 现在能正确拿到内容了！
        
        translated = translate_value(value)
        translated = t2s(translated)  # 保险起见再转一次简体
        
        return f'<string name="{name}">{translated}</string>'
    
    # 修复的正则：支持空格、换行、属性顺序不同
    pattern = r'<string\s+name="([^"]+)"[^>]*>(.*?)</string>'
    return re.sub(pattern, replace, content, flags=re.DOTALL | re.IGNORECASE)

def is_android_strings_xml(content: str) -> bool:
    return '<resources>' in content and '<string' in content

def convert_file(input_path: Path, output_path: Path):
    try:
        content = input_path.read_text(encoding="utf-8")
        
        if is_android_strings_xml(content):
            print(f"检测到 Android strings.xml，正在翻译：{input_path.name}")
            converted = translate_xml_strings(content)
        else:
            converted = t2s(content)
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(converted, encoding="utf-8")
        print(f"Success: {input_path} → {output_path}")
        
        print("\n========== 输出预览（前20行）==========")
        print('\n'.join(converted.splitlines()[:20]))
        print("===================================\n")
        
    except Exception as e:
        print(f"Failed: {input_path} | 错误: {e}")

# 主逻辑（同之前）
def process_single_file(input_path: Path, output_arg: str):
    if '.' in Path(output_arg).name:
        output_path = Path(output_arg)
    else:
        output_dir = Path(output_arg)
        output_dir.mkdir(parents=True, exist_ok=True)
        output_path = output_dir / input_path.name.replace(".xml", "_zh.xml").replace(".txt", "_zh.txt")
    
    convert_file(input_path, output_path)

def batch_process(input_dir: Path, output_dir: Path):
    output_dir.mkdir(parents=True, exist_ok=True)
    files = [p for p in input_dir.rglob("*.xml")]
    print(f"发现 {len(files)} 个 XML 文件，开始处理...")
    for f in files:
        process_single_file(f, str(output_dir))
    print("All Done!")

def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    input_arg = sys.argv[1]
    output_arg = sys.argv[2] if len(sys.argv) >= 3 else "output"
    
    input_path = Path(input_arg)
    if not input_path.exists():
        print(f"Error: 输入不存在: {input_arg}")
        sys.exit(1)
    
    if input_path.is_file():
        process_single_file(input_path, output_arg)
    else:
        batch_process(input_path, Path(output_arg))

if __name__ == "__main__":
    main()
